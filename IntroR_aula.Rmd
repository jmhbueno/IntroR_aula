---
title: "Introdução ao R"
author: "Maurício Bueno"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
  word_document:
    toc: yes
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: sentence
---

```{r echo=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE)
```

# Introdução

O R é uma **linguagem** e um **ambiente** de programação dentro do qual se pode fazer uma infinidade de operações estatísticas e de processamento de dados.
Foi concebido para ser colaborativo e gratuito.
Qualquer pessoa pode criar uma função, ou um conjunto de funções (pacote) e disponibilizar a outros usuários... **gratuitamente**!
Visite o [site](https://cran.r-project.org/) do R e baixe o programa para instalação em seu computador.

Em associação ao R, costuma-se usar o RStudio (baixe e instale clicando [aqui](https://www.rstudio.com/)), que facilita o uso do R ao disponibilizar um conjunto de quatro janelas que funcionam para as seguintes funções:

1)  digitação de texto (superior, à esquerda),
2)  display de resultados (console) (inferior, à esquerda),
3)  visualizador de objetos (arquivos) gerados ao realizar um trabalho (superior, à direita),
4)  informações gerais: arquivos, plotagens, pacotes instalados, help, e visualizador de imagens (inferior, à direita).

Para a digitação dos comandos, deve-se abrir um novo **Script** ou um **RMarkdown**.

Abre-se um novo **script** com a seguinte linha de comando: `File + New File + R Script`, cujo atalho é `CTRL+SHIFT+N`.

Abre-se um novo **RMarkdown** com a seguinte linha de comando: `File + New File + R Markdown` Fazendo isso, abrirá uma aba no quadrante superior esquerdo.

O **RMarkdown** aceita linhas de texto e linhas de código, mas as linhas de código devem ser escritas dentro de um **chunk**, que se abre com o comando `CTRL+ALT+i`.

Já o **Script** é um grande **chunk** e não aceita linhas de texto.
Por isso, preferimos usar o RMarkdown.

Seja Script ou RMarkdown, você pode abrir quantas abas desejar.

É possível rodar um comando no R de duas formas:

-   Selecionando-o e clicando em "Run" na aba superior da área de digitação.

-   Colocar o cursor em qualquer ponto da linha de comando e apertar `CTRL+ENTER`.

## Instalação e ativação de pacotes

Algumas funções não precisam da instalação de pacotes, pois já vêm com o R.
São funções básicas (base), como operações matemáticas, plotagem, estatísticas básicas, entre outras.
Outras funções estão em pacotes que precisam ser **instalados**, por meio do comando `install.packages()`, e **ativados**, por meio do comando `library()`.
Então, vamos instalar alguns pacotes que iremos utilizar durante o curso.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Instalação dos pacotes

# if(!require(readxl)) install.packages("readxl",repos = "http://cran.us.r-project.org")
# 
# if(!require(tidyverse)) install.packages("tidyverse",repos = "http://cran.us.r-project.org")
# if(!require(knitr)) install.packages("knitr",repos = "http://cran.us.r-project.org")
# if(!require(kableExtra)) install.packages("kableExtra", repos = "http://cran.us.r-project.org")
# if(!require(expss)) install.packages("expss", repos = "http://cran.us.r-project.org")
# 
# if(!require(tibble)) install.packages("tibble")
# Ativacao dos pacotes ====
library(readr)
library(readxl)
library(tidyverse)
library(knitr)
library(expss)
```

Todo pacote do R tem uma documentação, com informações sobre as funções que o pacote contém.
Uma forma de encontrar essa documentação é no site [rdocumentation.org](rdocumentation.org).

As funções contidas dentro dos pacotes ser acessadas digitando-se um ponto de interrogação (?) antes do nome da função.
Por exemplo, se quisermos a documentação da função **hist** da base do R, é só rodar o comando:

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
?hist()
```

A documentação aparecerá na aba **Help** do quadrante de visualizações de informações do RStudio.

## Operadores básicos

Existem também alguns operadores importantes no R, que você deve conhecer:\
Um deles é a seta para a esquerda, formada com o sinal de *menor* e o traço de *menos*: `<-`.

Atalho para esse operador: pressione simultaneamente as teclas `ALT` e `-`

Esse operador indica que o resultado de uma operação será salva em um **objeto**.

Por exemplo: o comando abaixo diz "*faça a soma de 3 com 4 e guarde o resultado num objeto chamado **soma**"*.
Esse objeto (soma) aparecerá no environment (quadrante superior direito do RStudio).

```{r}
soma <- 3 + 4 
```

O comando "\#" permite que você faça comentários, sem que o R o entenda como comando.
Por exemplo:

```{r}
soma <- 3 + 4   # Esse comando calcula a soma de 3 + 4 e salva no objeto "soma"
```

O texto que aparece após a #, em outra cor (verde, azul, etc.), é ignorado pelo R.
Esses são os comandos mais básicos.
Há muitos outros atalhos...

```{r echo=FALSE, message=FALSE, warning=FALSE}
atalhos <- data.frame(atalho  =c("CTRL + ENTER",
                                 "CTRL + SHIFT + C",
                                 "CTRL + 1",
                                 "CTRL + 2",
                                 "SETA PARA CIMA (no console)",
                                 "CTRL + ALT + SETA PARA ESQUERDA OU DIREITA",
                                 "CTRL + SHIFT + ENTER",
                                 "CTRL + S",
                                 "CTRL + L",
                                 "ALT + SHIFT + K"),
                      "o que faz"=c("Executa a linha selecionada",
                                    "Comenta e descomenta a linha",
                                    "Passa o cursor para o script",
                                    "Passa o cursor para o console",
                                    "acessa o histórico de comandos anteriores",
                                    "Navega entre as abas de script abertas",
                                    "Executa o Script inteiro",
                                    "Salva o Script",
                                    "Limpa o console",
                                    "Ver a lista de atalhos"
                                    ))
knitr::kable(atalhos, format = "markdown")
```

## Definir diretório de trabalho

Para facilitar o trabalho com salvamento e recuperação de arquivos, é recomendável que se defina um diretório de trabalho, onde todos os arquivos referentes à análise de dados serão salvos.

```{r}
# para verificar o diretório atual, execute o comando: 
getwd()

# OBS.: se for necessário, navegue até o local desejado utilizando a aba "files"

# defina sua pasta de trabalho utilizando a função: 
setwd("C:/Users/jmhbu/OneDrive/Documentos/R/R_basico/Intro_R")
```

## Principais operadores

O R pode ser usado como calculadora...

A tabela a seguir apresenta os principais operadores que usamos nos códigos em R.

```{r echo=FALSE, message=FALSE, warning=FALSE}
table_operadores <- data.frame(Operador = c("+","-","*","/",":","^","sqrt","==",
                                            ">","<","<=",">=","!","&","|"),
                               Descrição = c("Adição",
                                             "Subtração",
                                             "Multiplicação",
                                             "Divisão",
                                             "Sequência",
                                             "Exponencial",
                                             "Raiz",
                                             "Igualdade",
                                             "Maior que",
                                             "Menor que",
                                             "Menor ou igual",
                                             "Maior ou igual",
                                             "Não",
                                             "E",
                                             "Ou"))
knitr::kable(table_operadores, format = "markdown")
```

Exercitando...

```{r echo=TRUE, message=FALSE, warning=FALSE}

# operações matemáticas

3+4
5-2
4*2
9/3
sqrt(9)
2^3

1:10
10:1

#3 = 3
3 == 3
3 > 2
3 < 2
3 >= 2
3 >= 3
3 <= 2:5
3 + 4 >= 14/2

!3 == 5

1 < 2 & 2 < 3

1 == 2 | 2 > 3

```

## Operações lógicas

Algumas palavras são reservadas no R para operações lógicas.
As principais são TRUE, FALSE e NA.

```{r echo=FALSE, eval=TRUE}

op_logicos <- data.frame("Operadores lógicos" = c("NA","NaN","Inf","NULL","TRUE","FALSE"),
                         Significados = c("Not available - dado faltante/indiponível",
                                          "Not a number - indefinições matemáticas como 0/0, log(-1)",
                                          "Infinito - número muito grande, como 1/0 e 10^310",
                                          "Representa ausência de objeto",
                                          "Condição é verdadeira",
                                          "Condição é falsa"))
knitr::kable(op_logicos, format = "markdown")
```

## Criando objetos

Os objetos que podem ser criados no R são:

-   listas

-   vetores

-   matrizes

-   array

-   dataframes

Vamos definir os que mais usamos em nossas análises.

### Lista

**Lista**: é uma coleção de informações.

```{r}
minha_lista <- list("s01","masculino",23,"ensino médio")
class(minha_lista)

# minha_lista é um objeto do tipo lista, que guarda informações de diferentes tipos: id, sexo, idade, escolaridade
# essas informações foram salvas num objeto do tipo lista, que pode ser visto no environment
# informações não-numéricas aparecem entre "aspas" para o R reconhecer cada elemento dentro do objeto
# as informações dessa lista poderiam ser de um sujeito num df, cada informação é de uma natureza
# o comando "c", significa "concatenar". É usado para inserir mais de uma informação.
```

### Vetor

**Vetor**: é uma coleção de informações ou elementos **da mesma natureza**.
Por exemplo, as variáveis que costumamos colocar nas colunas dos nossos bancos de dados são **vetores**.

```{r}
meu_vetor <- c("masculino","feminino","feminino","masculino","feminino")
is.list(meu_vetor)
is.vector(meu_vetor)
is.data.frame(meu_vetor)

# meu_vetor é um objeto do tipo vetor porque contem informações da mesma natureza. Poderiam ser informações sobre o sexo dos sujeitos em um  banco de dados

vetor1 <- c(1, 5, 3, -10)
vetor2 <- c("a", "b", "c")

class(vetor1)
class(vetor2)

# Se tentarmos misturar duas classes, o R vai apresentar um comportamento conhecido como coerção. Ele vai impor uma das classes aos objetos. Por exemplo:

vetor <- c(1, 2, "a")

vetor
class(vetor)
```

### Dataframe

**Dataframe**: é um conjunto de vetores.
Nossos bancos de dados, no R, recebem o nome de dataframes.

```{r}
# criar vetor sexo, em que 1 é masculino e 2 é feminino.
sexo <- c(1,2,1,1,2)
is.vector(sexo)

# pode-se criar um vetor semelhante, mas com letras
# quando uma informação textual for inserida num objeto, ela tem que ir entre aspas.
sexo_cod <- c("m","f","m","m","f") # vetor com informações sobre sexo

# uma alternativa a isso é transformar a variável sexo em uma variável fator

sexo <- factor(sexo, levels = c(1,2), labels = c("masculino", "feminino"))

idade <- c(25,32,78,12,NA) # vetor com informações de idade

# A partir dos dois vetores anteriores é possível criar um dataframe (conjunto de vetores)
df <- data.frame(sexo_cod,idade)

# acrescentando a variável escolaridade
escolaridade <- c("superior","medio","fundamental","fundamental","medio")

cbind(df,escolaridade) # cbind() é uma função da base que anexa colunas.
df <- cbind(df,escolaridade) 

# acrescentando a variável id
id <- 1:5
df <- cbind(id,df)

# Se quiser inserir um "s" antes do número de cada sujeito, podemos usar a função paste(), que concatena duas partes da informação que constar em uma coluna. Essa função diz: concatene um s com valores de 1 a 5, separados por nada.

paste("s",1:5,sep="_")
id <- paste("s",1:5,sep="")

# uma forma de salvar os resultados em uma nova variável diretamente no banco de dados é usando a função $ (cifrão). Quando digitamos o $ em seguida ao nome do objeto (dataframe), o R abre, automaticamente, abre uma janela de opções com as variáveis que existem no dataframe. Ao selecionar "id", por exemplo, os novos dados serão salvos SOBRE os dados existentes. Caso se queira CRIAR uma nova variável, basta digitar o nome de uma variável inexistente no dataframe.

df$id <- paste("s",1:5,sep="")

# se quiser inserir um novo sujeito no dataframe

suj6 <- list(id="s6",sexo_cod="m",idade=34,escolaridade="superior")
suj6 <- list("s6","m",34,"superior")


rbind(df,suj6)
df <- rbind(df,suj6)
df
# inserir a variável renda
# seq(from,to,by,lenth)

df$renda <- seq(1000, by=500,length=6)
# ou
#renda <- seq(1000, by=500,length=6)
#df <- cbind(df,renda)

# inserir uma variável "bonus", referente a um abono de 500 reais a cada sujeito.
# usamos a função rep(), que é semelhante à variável seq(), sem o argumento "by", porque a informação é sempre a mesma
df$bonus <- rep(500,6)

# ou
#bonus <- rep(500,6)
#df <- cbind(df,bonus)

# calcular "renda total", que é a soma das variáveis renda e bonus
df$"renda total" <- df$renda + df$bonus

# inserir a variável "Estado Civil"
df$"estado civil" <- c("casado/a","solteiro/a","viúvo/a","solteiro/a","casado/a","casado/a")
df
```

# Funções para visualização de dados

```{r}
names(df)
str(df)
glimpse(df)
head(df)
ncol(df)
nrow(df)
view(df)
unique(df$"Estado Civil")
unique(df$idade)
df_copia <- df
df <- df_copia
```

# Exercícios 1

1.  Pense em um número de 1 a 10. Verifique, usando o R, se esse número está entre 3 e 8 (incluindo o 3 e o 8).

```{r}
5 >= 3 & 5 <= 8
```

Verifique, usando o R, se esse número **não está** entre 3 e 8 (excluindo o 3 e o 8).

```{r}
!5 > 3 | !5 < 8

5 < 3 | 5 > 8
```

Multiplique o número que você escolheu por 9.
Pegue o resultado dessa multiplicação e some os algarismos (por exemplo, se deu 16, a soma dos algarismos é 1 + 6 = 7).
Subtraia 5 desse resultado.
Quanto deu?

ok, agora transforme esse resultado na letra correspondente do abecedário (por exemplo, a=1, b=2...).
Pense num país que comece com essa letra!
Agora, pegue a 5ª letra desse país e pense num animal que comece com essa letra.
**Veja a resposta no final.**

```{r}
# Pensei no número 5
5 * 9
4 + 5
9 - 5

nchar("Dinamarca")
```

2.  Os quatro candidatos à presidência da república mais bem colocados nas pesquisas eleitorais são Lula (homem, 76 anos, Partido dos Trabalhadores), Bolsonaro (homem, 67 anos, Partido Liberal), Ciro Gomes (homem, 64 anos, Partido Democrático Trabalhista) e Simone Tebet (mulher, 52 anos, Movimento Democrático Brasileiro). Lula e Bolsonaro já exerceram a presiência da república, enquanto Ciro e Simone ainda não. Com essas informações, monte um dataframe chamdo brasil2022 contendo cinco colunas: id, nome, sexo, idade, partido e se exerceu a presidência anteriormente (sim ou não).

```{r}
brasil2022 <- 
data.frame(id = paste("c",1:4,sep = ""),
           nome = c("Lula","Bolsonaro","Ciro","Simone"),
           sexo = c("masculino","masculino","masculino","feminino"),
           idade = c(76,67,64,52),
           partido = c("PT","PL","PDT","MDB"),
           "já foi presidente?" = c("sim","sim","não","não"))

id <- paste("c",1:4,sep = "")
nome <- c("Lula","Bolsonaro","Ciro","Simone")

brasil2022 <- data.frame(id,nome)
brasil2022$sexo <- c("masculino","masculino","masculino","feminino")
brasil2022$idade <- c(76,67,64,52)
brasil2022$partido <- c("PT","PL","PDT","MDB")
brasil2022$"já foi presidente?" <- c("sim","sim","não","não")


# Idade <- c(76,67,64,52)
# 
# cbind(brasil2022,Idade)
```

3.  Quais são as classes das variáveis desse dataframe?

```{r}
str(brasil2022)
class(brasil2022)
class(brasil2022$idade)
```

4.  Acrescente ao dataframe `brasil2022` uma linha com as informações do candidato Sílvio Santos, que é homem, tem 91 anos, nunca foi presidente anteriormente e não se tem informação sobre seu partido de afiliação.

```{r}
silviosantos <- list("c5","Silvio Santos","masculino",91,NA,"não")
brasil2022 <- rbind(brasil2022,silviosantos)
```

5.  Transforme as variáveis sexo e se já foi presidente em fatores.

```{r}
brasil2022$sexo <- 
factor(brasil2022$sexo, levels = c("masculino","feminino"), labels = c("m", "f"))

brasil2022$`já foi presidente?` <- 
factor(brasil2022$`já foi presidente?`, levels = c("não","sim"), labels = c("n", "s"))

str(brasil2022)
```

6.  Se sua resposta foi macaco, você errou, porque na Dinamarca não tem macacos!!! Mas parabéns, você realizou as contas corretamente no R.

# Funções para manipulação de dados

Muitas vezes, precisamos manipular os dados de um dataframe, seja para renomear colunas, selecionar linhas ou colunas, adicionar variáveis ou sujeitos, entre outras.
Vejamos algumas delas.

## Alteração do nome de variáveis

```{r}
# Alterar o nome da variável "sexo_cod"
saveRDS("df","df.rds")

df <- rename(df,sexo = "sexo_cod")

# Para se alterar o nome de muitas variáveis, por exemplo, substituindo os espaços 
# em branco (" ") por underline ("_"), pode-se usar a função gsub, da base do R.

names(df) <- gsub(" ","_",names(df))

# essa função diz: vá nos nomes das variáveis de df e sibstitua os espaços em branco (" ") por underline ("_") 
```

## Selecionar linhas e colunas

```{r}
# Selecionar linhas e colunas: dataframe[linhas,colunas]

df[1:3, ] # seleção das três primeiras linhas
df[ ,1:3] # seleção das três primeiras colunas 
df[1:3,1:3] # seleção das três primeiras linhas e das três primeiras colunas

# Se que quisermos selecionar as linhas 1, 3 e 6, como fazemos?
df[c(1,3,5), ]

# se quisermos selecionar as colunas id, idade e renda_total
df[ ,c(1,3,7)]
df[ ,c("id","idade","renda_total")]
df[ ,c("renda_total","idade","id")]
```

## Filtrar linhas inteiras

```{r}
# Selecionar somente as linhas dos participantes do sexo masculino
df[df$sexo == "m",  ]

# Selecionar somente as linhas dos participantes do sexo masculino com renda_total maior ou igual a 2500 reais.
df[df$sexo == "m" & df$renda_total >= 2500, ]
```

## Alterar o conteúdo dentro de uma variável

```{r}
# Alterar o conteúdo dentro de uma variável

df$sexo[df$sexo == "f"] <- 0
df$sexo[df$sexo == "m"] <- 1
```

## Alterar o formato de variáveis

```{r}
# visualisar que a variável sexo está como character, mas também foi possível perceber que outras variáveis também não estão no formato ideal. Vamos acertar todas elas.

str(df)

# mudar variável sexo para factor (note que está como caractere)
df$sexo <- as.numeric(df$sexo)
df$sexo <- as.factor(df$sexo) # factor é uma variável nominal
# df$sexo <- c("m","f","m","m","f","m")

# df$idade <- as.numeric(df$idade)
df$escolaridade <- as.factor(df$escolaridade)
```

## Atribuir níveis às variáveis de fator

```{r}
# atribuir levels aos valores 0 e 1 da variável sexo
levels(df$sexo) <- c("feminino","masculino")
levels(df$escolaridade) <- c("fundamental","médio","superior")
str(df)
```

## Alterar a ordem das variáveis no dataframe

```{r}
# Alterar a ordem das variáveis no banco de dados
df <- df[ ,c("id","sexo","idade","escolaridade","estado_civil",
             "renda","bonus","renda_total")]
```

# Exercícios 2

```{r eval=FALSE, include=FALSE}

# Gerando um arquivo imdb em rds para os alunos

imdb1000 <- read.csv("imdb_top_1000.csv",encoding = "UTF-8")

# Codigo abaixo para limpar variáveis de texto
# imdb1000 <- imdb1000[,-c(1,8)]

# Separar a variável gênero em três variáveis (Genre1, Genre2 e Genre3)
imdb1000 <- imdb1000 %>% separate(Genre, sep = ",", into = c("Genre1","Genre2","Genre3"))

saveRDS(imdb1000,"imdb1000.rds")
```

O *Internet Movie Database*, conhecido popularmente como IMDb, é uma base de dados de informação sobre cinema TV, música e games pertencente à Amazon.
Vamos trabalhar com um arquivo que apresenta diversas informações de 1000 filmes.
Para isso, temos que seguir dois passos: 1) salvar o arquivo em nosso computador e 2) importar o arquivo para dentro do R.
Então vamos lá...

Baixe o arquivo [imdb1000.rds](https://github.com/jmhbueno/IntroR_aula/blob/09435ea3036667d756bbc7aef4cd4a6ebdfa4b39/imdb1000.rds) e **salve-o na pasta que você está utilizando para as aulas do R**.

Agora é necessário importar o arquivo `imdb.rds` para dentro do R, salvando-o como imdb.
Para isso, use o código de importação abaixo:

```{r echo=TRUE}
imdb1000 <- readRDS("imdb1000.rds")
# OBS: Esse código só irá funcionar se o arquivo estiver salvo na pasta em que vc está trabalhando.
```

Quantas linhas e colunas tem o dataframe imdb?

```{r echo=TRUE}
str(imdb1000)
nrow(imdb1000)
ncol(imdb1000)
```

Mostre os filmes desse banco de dados foram dirigidos por Woody Allen?

```{r echo=TRUE}
imdb1000[imdb1000$Director == "Woody Allen",c("Series_Title","Director")]
```

Exiba um dataframe que mostra os títulos dos filmes dirigidos por Steven Spielberg que foram lançados até o ano 2000?

```{r echo=TRUE}
imdb1000[imdb1000$Director == "Steven Spielberg" & imdb1000$Released_Year <= 2000,
     c("Released_Year","Director","Series_Title")]
```

Exiba um dataframe que mostre os titulos dos filmes dirigidos por Steven Spielberg ou James Cameron, que são do gênero drama ou ação **(Somente em Genre1)**.

```{r echo=TRUE}

imdb1000[(imdb1000$Director == "James Cameron" | imdb1000$Director == "Steven Spielberg") & (imdb1000$Genre1 == "Drama" | imdb1000$Genre1 == "Action"), c("Series_Title","Genre1","Director")]
```

Renomeie as variáveis, traduzindo-as para o português.

```{r echo=TRUE}
imdb1000 <- 
rename(imdb1000,c(título = "Series_Title",
              lançamento = "Released_Year",
              certificado = "Certificate",
              duração = "Runtime",
              gênero1 = "Genre1",
              gênero2 = "Genre2",
              gênero3 = "Genre3",
              imdb = "IMDB_Rating",
              meta_escore = "Meta_score",
              diretor = "Director",
              ator1 = "Star1",
              ator2 = "Star2",
              ator3 = "Star3",
              ator4 = "Star4",
              votos = "No_of_Votes",
              custo = "Gross"))
```

Vamos fazer mais alguns exercícios com um banco de dados sobre a população mundial.
Salve o arquivo [world_populations.csv](https://1drv.ms/u/s!ApvtT9NG4aYok61vBm-Wnr5PWATIWA?e=Skesjw) no diretório que você está utilizando para esta disciplina.
Em seguida, importe esse banco de dados para dentro do R usando o código abaixo:

```{r echo=TRUE}
# Importar banco de dados de um arquivo .csv para um dataframe no R chamado world_population

# Note que, neste caso, estamos usando a função read.csv() porque o arquivo está no formato .csv (informações separadas por vírgulas)
wp <- read.csv("world_population.csv", encoding = "UTF-8")
# wp_copia <- wp
```

```{r eval=FALSE, include=FALSE}
# código para substituir pontos por espaço no nome das variáveis (não utilizei)
names(wp) <- gsub("\\.", " ",names(wp))
```

Crie um dataframe chamado `wp1` que permita identificar as capitais de todos os países da América do Sul (países e capitais)

```{r echo=TRUE}
wp1 <- wp[wp$Continent == "South America",3:4]
```

Para colocar a coluna "Country" em ordem alfabética, podemos usar a função `order()` dentro dos colchetes.
Veja:

```{r echo=TRUE}
wp1[order(wp1$Country),]
```

Selecione informações do dataframe wp que permita comparar os casos de Brazil, China, Rússia e Índia quanto às seguintes variáveis: população em 2020, densidade por km^2^, taxa de crescimento e porcentagem da população mundial.
Salve essa seleção em um novo objeto chamado wp2.

```{r echo=TRUE}
names(wp)

wp2 <- 
wp[wp$Country == "Brazil" | wp$Country == "China" | wp$Country == "Russia" | wp$Country == "India",c(3,7,15:17)]
```

Ordene o dataframe wp2 pelas suas variáveis.
Dica, você pode usar o argumento `decreasing = TRUE` dentro da função `order()` para ordenar a coluna de forma decrescente.
Teste essa possibilidade.

```{r echo=TRUE}
wp2[order(wp2$Country),]
wp2[order(wp2$X2020.Population, decreasing = TRUE),]
wp2[order(wp2$`Density..per.km².`, decreasing = TRUE),]
wp2[order(wp2$Growth.Rate, decreasing = TRUE),]
wp2[order(wp2$World.Population.Percentage, decreasing = TRUE),]
```

## Importar e Combinar dataframes

```{r include=FALSE}
# importar planilha para o objetivo variables
# df_copia1 <- df
# df <- df_copia1
variables <- read_xlsx("Variables.xlsx")

```

Nesse caso, temos o dataframe `variables`, com a informação de cinco variáveis dos mesmos sujeitos que constam no dataframe `df`.
Então, gostaríamos de juntar esses dois dataframes.
Para isso podemos usar duas funções.

```{r}
# Juntar a planilha importada no dataframe df
saveRDS(df,"df.rds")
df <- cbind(df,variables)
```

## Lidando com dados ausentes

A função `na.omit` deleta as informações de uma linha inteira que contenha ao menos uma informação ausente.\

A função `na.exclude` faz quase a mesma coisa, mas apenas omite a linha e acaba reportando alguns resultados, como resíduos, por exemplo, em análises de regressão.
Além disso, também preserva o número de linhas do dataframe.
Isso é importante em certas ocasiões que se deseja manter constante o número de linhas de um dataframe para coincidir com outro dataframe, por exemplo.

```{r}
na.omit(df)
na.exclude(df)
```

Uma outra forma de lidar com dados ausentes (NA) é através de um argumento que geralmente é utilizado dentro de funções estatísticas ou gráficos para sinalizar que os valores NA devem ser ignorados. Esse argumento é o `na.rm`, que é um argumento lógico, ou seja deve ser apresentado como `na.rm = TRUE` ou `na.rm = FALSE`. Veja a aplicação desse argumento na função `mean()`, utilizada para calcular médias.

```{r}
# mean(df$idade)    # essa função acaba não rodando, porque entre os dados de idade existe um NA
mean(df$idade, na.rm = TRUE) # dessa forma, conseguimos rodar a análise.
```

# Função `ifelse()`

A função `ifelse()` é bastante útil para a manipulação de dados.
Ela deve ser escrita da seguinte forma: `ifelse("condição", "se sim", "se não")` Traduzindo: observe a condição... se ela ocorrer, faça isso... se ela não ocorrer, faça aquilo.
Exemplos:

```{r}
# se quisermos classificar a renda em dois grupos: menor igual a R$2000 e maior que R$2000, podemos usar a função ifelse()
# ifelse(condição,se sim, se não)
# traduzindo....
# observe se, na variável renda, o valor é menor ou igual a 2000
# se for, então atribua 1
# se não for, então atribua 2.

ifelse(df$renda <= 2000,1,2)

# Se quisermos salvar esses dados como uma coluna do df...
df$renda_cod <- ifelse(df$renda <= 2000,1,2)

# se quisermos criar uma coluna atribuindo 1 para homens e 0 para os demais.
ifelse(df$sexo == "masculino",1,0)

# se quisermos identificar homens com escolaridade fundamental
ifelse(df$sexo == "masculino" & df$escolaridade == "fundamental",1,0)

# se quisermos identificar homens com escolaridade fundamental OU pessoa casadas.
ifelse(df$sexo == "masculino" & df$escolaridade == "fundamental" | df$estado_civil == "casado/a",1,0)

# se quisermos criar uma nova variável atribuindo 1 para solteiro, 2 para casado e 3 para viúvo... tínhamos visto o formato

#df$escolaridade[df$escolaridade == "fundamental"] <- 1
#df$escolaridade[df$escolaridade == "médio"] <- 2
#df$escolaridade[df$escolaridade == "superior"] <- 3

df$escola_cod <- ifelse(df$escolaridade == "fundamental",1,
                        ifelse(df$escolaridade == "médio",2,3))

ifelse(df$v1 == 1,5,
       ifelse(df$v1 == 2,4,
              ifelse(df$v1 == 3,3,
                     ifelse(df$v1 == 4,2,1))))

# Também é possível recodificar variáveis de jeito mais fácil, usando uma função do pacote expss.
# Note que há questões no sentido de uma boa adaptação aos estudos e frases no sentido contrário. Nesses casos, não podemos somar os itens diretamente porque um valor 5 em v1 significa má adaptação, enquanto o mesmo valor 5  significa boa adaptação em v2. Então, não podemos somar coisas que têm significados diferentes.
# Para lidar com isso, geralmente, fazemos a inversão de itens que estão na direção contrária do que queremos avaliar. Por exemplo, se queremos avaliar "adaptação escolar", então invertemos os itens v1 e v5, que estão na direção contrária.
# Inverter significa transformar 1 em 5, 2 em 4, 3 em 3, 4 em 2 e 5 em 1. 
# Para isso, usamos a função recode() do expss.

recode(df[ ,c("v1","v2","v3","v4","v5")]) <- c(1~5,2~4,3~3,4~2,5~1)
recode(df[ ,c("v1","v5")]) <- c(1~5,2~4,3~3,4~2,5~1)
```

# Exercícios 3
### Importar arquivo do Excel para o R

Nesta atividade, nós vamos um banco de dados público, que contém algumas informações sobre os respondentes e 50 itens de um teste de personalidade.

Os itens estão na seguinte ordem: extroversão (E), neuroticismo (N), amabilidade (A), conscienciosidade (C) e Abertura (O).

Copie o arquivo [big_five.xlsx](https://github.com/jmhbueno/Intro_R/blob/84e90af00f68cf20693e53d394709cc4538c2b40/big_five.xlsx) para a pasta de trabalho que você está usando para esta disciplina.

Esse é um banco de dados estrangeiro, está codificado no sistema europeu.

Use a função `read_excel()` do pacote `readxl` para importá-lo e salve-o como um objeto do R chamado `big_five`.

Dentro dos parênteses informamos o nome do arquivo, entre aspas e com a extensão. Veja...

```{r message=FALSE, warning=FALSE}

# Você deve ter instalado o pacote readxl em nossa última aula.
# se ainda não instalou, instale-o utilizando o comando install.packages("readxl")
# Depois, não se esqueça de ativar o pacote com a função library(readxl)

big_five <- read_excel("big_five.xlsx")

# ao rodar o comando, o arquivo será importando e salvo como dataframe no R. Você verá um objeto com esse nome, no quadro superior à direita.
```

### Informações sobre o banco de dados

O banco de dados utilizado neste exercício (baixado da internet) foram coletados (c. 2012) por meio de um teste de personalidade online interativo.
Os itens foram avaliados em uma escala de cinco pontos, em que 1 = Discordo, 3 = Neutro, 5 = Concordo (0 = não respondido).
Os itens foram os seguintes:

E1 - I am the life of the party.

E2 - I don't talk a lot.

E3 - I feel comfortable around people.

E4 - I keep in the background.

E5 - I start conversations.

E6 - I have little to say.

E7 - I talk to a lot of different people at parties.

E8 - I don't like to draw attention to myself.

E9 - I don't mind being the center of attention.

E10 - I am quiet around strangers.

N1 - I get stressed out easily.

N2 - I am relaxed most of the time.

N3 - I worry about things.

N4 - I seldom feel blue.

N5 - I am easily disturbed.

N6 - I get upset easily.

N7 - I change my mood a lot.

N8 - I have frequent mood swings.

N9 - I get irritated easily.

N10 - I often feel blue.

A1 - I feel little concern for others.

A2 - I am interested in people.

A3 - I insult people.

A4 - I sympathize with others' feelings.

A5 - I am not interested in other people's problems.

A6 - I have a soft heart.

A7 - I am not really interested in others.

A8 - I take time out for others.

A9 - I feel others' emotions.

A10 - I make people feel at ease.

C1 - I am always prepared.

C2 - I leave my belongings around.

C3 - I pay attention to details.

C4 - I make a mess of things.

C5 - I get chores done right away.

C6 - I often forget to put things back in their proper place.

C7 - I like order.

C8 - I shirk my duties.

C9 - I follow a schedule.

C10 - I am exacting in my work.

O1 - I have a rich vocabulary.

O2 - I have difficulty understanding abstract ideas.

O3 - I have a vivid imagination.

O4 - I am not interested in abstract ideas.

O5 - I have excellent ideas.

O6 - I do not have a good imagination.

O7 - I am quick to understand things.

O8 - I use difficult words.

O9 - I spend time reflecting on things.

O10 - I am full of ideas.

**race** (raça): Foi escolhida pelos participantes em um menu suspenso.

0 = Dados perdidos

1 = Raça Mista

2 = Ártico (Siberiano, Esquimó)

3 = Caucasiano (Europeu)

4 = Caucasiano (Indiano)

5 = Caucasiano (Médio Leste)

6 = Caucasiano (Norte Africano, Outro)

7 = Indígena Australiano

8 = Nativo Americano

9 = Nordeste Asiático (Mongol, Tibetano, Japonês Coreano, etc)

10 = Pacífico (Polinésia, Micronésia, etc.)

11 = Sudeste Asiático (Chinês, Tailandês, Malaio, Filipino, etc.)

12 = Oeste da África, Bosquímanos, Etíope

13 = Outro

**age**: inserida como texto (indivíduos que relataram idade \<13 anos não foram registrados)

**engnat**: Resposta a "o inglês é sua língua nativa?": 0 = dados perdidos, 1 = sim, 2 = não

**gender**: Escolhido em um menu suspenso.
0 = dados perdidos, 1 = Masculino, 2 = Feminino, 3 = Outro

**hand**: "Com que mão você escreve?".
0 = dados perdidos, 1 = Direita, 2 = Esquerda, 3 = Ambos

**country**: Código ISO do país.

**source**: Como o participante soube do teste.
1 = de outra página no site de teste 2 = do google 3 = do facebook 4 = de qualquer url com ".edu" em seu nome de domínio (por exemplo, xxx.edu, xxx.edu.au), 5 = não informado no arquivo 6 = outra fonte ou HTTP Referer não fornecido.

1.  Visualise o banco de dados com as funções names() e view() para checar se tudo foi importado corretamente.

```{r echo=TRUE}
big_five_cópia <- big_five
names(big_five)
str(big_five)
```

2.  Quantas variáveis existem no banco de dados?

```{r echo=TRUE}
ncol(big_five)
```

3.  Quantos sujeitos constam no banco de dados?

```{r echo=TRUE}
nrow(big_five)
```

4.  Como as variáveis estão codificadas no banco de dados (character, numeric, factor, etc...)? Obs: uma variável numérica pode estar como número inteiro (int) ou como número decimal (dbl).

```{r echo=TRUE}
str(big_five)
```

5.  Renomeie as variáveis, traduzindo-as para o português: raça = race, idade = age, ing_nat = engnat, gênero = gender, mão_dom = hand, fonte = source, país = country. Salve essa modificação no dataframe *big_five*.

```{r echo=TRUE}
big_five <- rename(big_five,c(raça = race, idade = age, ing_nat = engnat, gênero = gender, mão_dom = hand, fonte = source, país = country))
```

6.  Crie uma coluna **id** para identificar os sujeitos com um "s" seguido do número do sujeito. Por exemplo, s1, s2, s3... sn. Posicione essa coluna como a primeira do banco de dados.

```{r echo=TRUE}
# para não ter que reordenar as variáveis depois que id estiver no final do dataframe, pode-se criar um vetor com os ids e depois fazer um cbind com o big_five.

id <- paste("s",1:nrow(big_five),sep = "")
big_five <- cbind(id,big_five)

# essa função do dplyr reloca colunas para o início do dataframe
# big_five %>% relocate(id) %>% names()
```

7.  As variáveis raça, ing_nat, gênero e mão_dom estão codificadas como número inteiro (integer, abreviado como int). Transforme-as em fatores.

```{r echo=TRUE}
str(big_five)
big_five$raça <- as.factor(big_five$raça)
big_five$ing_nat <- as.factor(big_five$ing_nat)
big_five$gênero <- as.factor(big_five$gênero)
big_five$mão_dom <- as.factor(big_five$mão_dom)
big_five$"país" <- as.factor(big_five$"país")
```

8.  Agora é necessário atribuir os níveis de cada variável que foi transformada em fator. Os níveis para cada variável estão descritos no início deste documento. Lembrete: os níveis têm que ser atribuídos na mesma ordem dos valores. Por exemplo, na variável *gênero* o número 1 foi atribuído a *Masculino*, 2 a *Feminino* e 3 a *Outros.* Além disso, o valor 0 foi atribuído a respostas faltantes. Essas precisam ser transformadas em NA no R. Portanto, temos 0, 1, 2 e 3 no banco de dados, e os nomes desses níveis devem aparecer nessa ordem na linha de comando dessa variável.

```{r echo=TRUE}
levels(big_five$raça) <- c(NA,
                           "Raça Mista",
                           "Ártico (Siberiano, Esquimó)",
                           "Caucasiano (Europeu)",
                           "Caucasiano (Indiano)",
                           "Caucasiano (Médio Leste)",
                           "Caucasiano (Norte Africano, Outro)",
                           "Indígena Australiano",
                           "Nativo Americano",
                           "Nordeste Asiático (Mongol, Tibetano, Japonês Coreano, etc)",
                           "Pacífico (Polinésia, Micronésia, etc.)",
                           "Sudeste Asiático (Chinês, Tailandês, Malaio, Filipino, etc.)",
                           "Oeste da África, Bosquímanos, Etíope",
                           "Outro"
                           )
```

```{r echo=TRUE}
levels(big_five$ing_nat) <- c(NA,"Sim","Não")
#factor(big_five$ing_nat, levels = c(0,1,2), labels = c(NA,"Sim","Não"))
```

```{r echo=TRUE}
levels(big_five$gênero) <- c(NA,"Masculino","Feminino","Outro")
```

```{r echo=TRUE}
levels(big_five$mão_dom) <- c(NA,"Direita","Esquerda","Ambas")

```

9.  Rode a função `count(big_five,idade)` para contar quantas pessoas de cada idade há no banco de dados. Observe se há algo estranho.
10. Selecione apenas os participantes com idades até 80 anos (inclusive) e provenientes dos Estados Unidos (US). Salve esses participantes em um novo dataframe chamado **bf80us**.

```{r echo=TRUE}
bf80us <- big_five[c(big_five$idade <= 80 & big_five$país == "US"), ]
```

11. Quantos sujeitos compõem esse novo banco de dados?

```{r echo=TRUE}
nrow(bf80us)
```

12. Exporte o scritp deste exercício no formato `.rds` usando a função `saveRDS(nome_do_dataframe,"nome_do_arquivo.rds")` e envie o arquivo pelo google classroom para cumprir a atividade desta semana.

```{r echo=TRUE}
saveRDS(bf80us,"bf80us.rds")

```

13. Voltando a trabalhar com o dataframe `big_five`, criar uma nova variável chamada faixa_etária com as seguintes faixas: até 20 anos (1), de 21 a 30 (2), 31 a 40 (3), 41 a 50 (4), 51 a 60 (5), 61 a 70 (6), 71 a 80 (7) e atribua NA para valores superiores a 80. Salve essa nova variável no dataframe big_five.

```{r echo=TRUE}

big_five$faixa_etária <- ifelse(big_five$idade <= 20, 1,
                         ifelse(big_five$idade > 20 & big_five$idade <= 30,2,
                         ifelse(big_five$idade > 30 & big_five$idade <= 40,3,
                         ifelse(big_five$idade > 40 & big_five$idade <= 50,4,
                         ifelse(big_five$idade > 50 & big_five$idade <= 60,5,
                         ifelse(big_five$idade > 60 & big_five$idade <= 70,6,
                         ifelse(big_five$idade > 70 & big_five$idade <= 80,7,NA)))))))
str(big_five)
```



```{r eval=FALSE, include=FALSE}
# 14. Atribua labels (`apply_labels()`) aos itens do teste de personalidade, usando as afirmações que foram respondidas pelos participantes da pesquisa. (PERGUNTA RETIRADA POR SE REFERIR AO apply-labels)
# cópia_de_segurança2 <- big_five
# library(expss)
# big_five  <- apply_labels(big_five,
# E1  = "I am the life of the party",
# E2  = "I don't talk a lot",
# E3  = "I feel comfortable around people",
# E4  = "I keep in the background",
# E5  = "I start conversations",
# E6  = "I have little to say",
# E7  = "I talk to a lot of different people at parties",
# E8  = "I don't like to draw attention to myself",
# E9  = "I don't mind being the center of attention",
# E10 = "I am quiet around strangers",
# N1  = "I get stressed out easily",
# N2  = "I am relaxed most of the time",
# N3  = "I worry about things",
# N4  = "I seldom feel blue",
# N5  = "I am easily disturbed",
# N6  = "I get upset easily",
# N7  = "I change my mood a lot",
# N8  = "I have frequent mood swings",
# N9  = "I get irritated easily",
# N10 = "I often feel blue",
# A1  = "I feel little concern for others",
# A2  = "I am interested in people",
# A3  = "I insult people",
# A4  = "I sympathize with others' feelings",
# A5  = "I am not interested in other people's problems",
# A6  = "I have a soft heart",
# A7  = "I am not really interested in others",
# A8  = "I take time out for others",
# A9  = "I feel others' emotions",
# A10 = "I make people feel at ease",
# C1  = "I am always prepared",
# C2  = "I leave my belongings around",
# C3  = "I pay attention to details",
# C4  = "I make a mess of things",
# C5  = "I get chores done right away",
# C6  = "I often forget to put things back in their proper place",
# C7  = "I like order",
# C8  = "I shirk my duties",
# C9  = "I follow a schedule",
# C10 = "I am exacting in my work",
# O1  = "I have a rich vocabulary.",
# O2  = "I have difficulty understanding abstract ideas",
# O3  = "I have a vivid imagination",
# O4  = "I am not interested in abstract ideas",
# O5  = "I have excellent ideas",
# O6  = "I do not have a good imagination",
# O7  = "I am quick to understand things",
# O8  = "I use difficult words",
# O9  = "I spend time reflecting on things",
# O10 = "I am full of ideas")
```

14. Nos cinco fatores desse instrumento, há itens na direção do fator e itens no sentido inverso. Por exemplo, na escala de extroversão há itens como *"I am the life of the party"*, que descreve uma pessoa extrovertida, e itens como *"I don't talk a lot"*, que descreve uma pessoa introvertida. Esse problema precisa ser resolvido antes de calcularmos os escores das pessoas nesse fator. Se as pessoas responderam esses itens usando uma escala Likert de 5 pontos, não podemos somar os valores desses itens diretamente porque eles têm significados diferentes. Por exemplo, se uma pessoa atribuiu valor 5 ao item *"I am the life of the party"*, esse 5 indica que ela é muito **ex**trovertida. Mas o mesmo valor 5 atribuído ao item *"I don't talk a lot"* indica que a pessoa é muito **in**trovertida. Portanto, temos um problema porque o mesmo valor (5) significa coisas diferentes em itens diferentes. Para evitarmos esse problema temos que inverter os valores dos itens que vão na direção da introversão, mudar o 1 para 5, o 2 para 4, o 3 permanece 3, o 4 para 2 e o 5 para 1.

Faça essas alterações usando a função `ifelse()` para os itens invertidos do fator Exgtroversão e a `recode()` para os itens invertidos dos demais fatores ()

```{r echo=TRUE}
library(expss)

# uma solução seria usar ifelse
#big_five$E2_mod <- 
ifelse(big_five$E2 == 1,5,ifelse(big_five$E2 == 2,4,ifelse(big_five$E2 == 3,3,ifelse(big_five$E2 == 4,2,ifelse(big_five$E2 == 5,1,NA)))))
ifelse(big_five$E4 == 1,5,ifelse(big_five$E4 == 2,4,ifelse(big_five$E4 == 3,3,ifelse(big_five$E4 == 4,2,ifelse(big_five$E4 == 5,1,NA)))))
ifelse(big_five$E6 == 1,5,ifelse(big_five$E6 == 2,4,ifelse(big_five$E6 == 3,3,ifelse(big_five$E6 == 4,2,ifelse(big_five$E6 == 5,1,NA)))))
ifelse(big_five$E8 == 1,5,ifelse(big_five$E8 == 2,4,ifelse(big_five$E8 == 3,3,ifelse(big_five$E8 == 4,2,ifelse(big_five$E8 == 5,1,NA)))))

# no entanto, essa solução exigiria criar um código desse para cada variável.
# a função recode() do expss facilita a modificação de variáveis em bloco.

recode(big_five[ ,c('E2','E4','E6','E8','E10','N2','N4','A1','A3','A5','A7','C2','C4','C6','C8','O2','O4','O6')]) <- c(1~5,2~4,3~3,4~2,5~1,NA~NA)
```

# Importar e exportar arquivos de/para outros formatos

Há vários pacotes para importação de arquivos elaborados em outros programas, como o Excel e o SPSS, por exemplo, que são muito comuns em pesquisas em Psicologia.
De forma semelhante, às vezes, analisamos os dados no R/RStudio, salvamos a planilha em um dataframe, mas gostaríamos de exportar essa planilha para outros formatos, para serem lidos por outros programas, por exemplo.
A seguir, veremos como fazer isso, começando pela **exportação de arquivos**.

## Exportação de arquivos usando função da base

```{r}

saveRDS(df,"df.rds") # formato reconhecido pelo R
```

### Usando funções do pacote utils

```{r}

 write.csv(df,               # dataframe a ser exportado
           "df1.csv",         # nome a ser dado ao dataframe exportado
           sep = ",",         # caractere que separa as colunas
           na = "NA",         # como codificar dados faltantes
           dec = ".",         # que caractere usar para separar casas decimais
           col.names = TRUE)  # informar se Há (TRUE) ou não (FALSE) nome das colunas no dataframe

 write.csv2(df,              # semelhante ao comando anterior, mas assumindo sep = ";" e dec = ","
           "df1.csv",
           sep = ";",
           na = "NA",
           dec = ",",
           col.names = TRUE)

### OBS.: Essas funções acima podem ser resumidas para...
write.csv(df, "df.csv")
write.csv2(df, "df.csv")
```

### Usando funções do pacote readr

```{r}
# Carregar os pacotes readr
# install.packages("readr")
library(readr)

write_csv(
  df,
  "df.csv",
  na = "NA",
  col_names = TRUE)

write_csv2(
  df,
  "df.csv",
  na = "NA",
  col_names = TRUE)

write_excel_csv(
  df,
  "df.csv",
  na = "NA",
  col_names = TRUE,
  delim = ",")

write_excel_csv2(
  df,
  "df.csv",
  na = "NA",
  col_names = TRUE,
  delim = ";")
```

## Importação de arquivos

### Importando arquivos em `.csv` com o pacote `utils`

```{r}
# Importando arquivos em .csv

## Usando o pacote utils

#### read.csv(df.csv, header = TRUE, sep = ",", dec = ".", encoding = "UTF-8")
read.csv2("df.csv",             # nome do arquivo a ser importado (OBS. deve estar no diretório de trabalho)
          header = TRUE,        # TRUE, para arquivos com nomes das colunas
          sep = ";",            # caractere separador das colunas
          dec = ",",            # caractere separador de casas decimais.
          encoding = "UTF-8")   # usar codificação UTF-8 para que os acentos, etc. venham de forma correta.
```

### Importando arquivos em `.csv` com o pacote `readr`

```{r}
## Usando o pacote readr

# read_csv2("df.csv", col_names = TRUE, na = "NA", skip_empty_rows = TRUE)

# OBS: essa função não estava funcionando em 17/09/2022. Não consegui descobrir porque. Então desliguei a função para poder prosseguir.

```

### Importando arquivos em `.xls` e `.xlsx` (Excel) com o pacote `readxl`

```{r}
## Usando o pacote readxl para importar arquivos em excel
library(readxl)
read_excel("df.xlsx", col_names = TRUE)
```

### Importando arquivos em `.sav` (SPSS) com o pacote `haven`

```{r}
## Usando o pacote haven para importar arquivos do SPSS

# install.packages("haven")
library(haven)

read_sav("df.sav")
```

# Pacote `tidyverse`

O `tidyverse` é uma família de pacotes que compartilham a mesma filosofia e linguagem de programação.
Fazem parte dessa família pacotes como o `dplyr`, o `tidyr`, o `readr` e o `ggplot2`, entre outros.
O `dplyr` e o `tidyr` são pacotes com funções para a **manipulação de dados**, O `ggplot2` é um pacote poderoso para fazer **gráficos** e o `readr` permite a importação e exportação de dados.

Uma função básica do Tidyverse é a **função pipe** `%>%`, que se obtém pressionando as teclas `CTRL+SHIFT+M`.
Essa função pode ser interpretada como "então" e permite escrever códigos na sequência em que ocorrem.
Por exemplo:

```{r}
# para criar e inserir uma variável no banco de dados, ao invés de usar o sistema tradicional, podemos usar a linguagem tidy.

df %>% group_by(sexo) %>% summarise(média = mean(idade))
df %>% group_by(sexo) %>% summarise(média = mean(idade, na.rm = TRUE))
str(df)
```

Na sintaxe acima, usamos algumas funções que serão discutidas a seguir, mas é possível ver como escrevemos os códigos usando o pipe.

Em português, esse código ficaria assim: pegue o dataframe df, **então** agrupe pela variável sexo, **então** calcule as médias de idade.

Esse comando ajuda bastante a escrever códigos mais complexos.

## Operador `%in%`

O operador `%in%` pode ser traduzido como *está contido em*. Então, se quiser saber se a opção "não-binário" está contida numa variável sexo, pode-se usar o seguinte comando:

```{r}
"Não-binário" %in% df$sexo

# se quisermos saber quais sujeitos são casados ou solteiros...

df$estado_civil %in% c("casado/a","solteiro/a")

# se quisermos saber se as opções casado/a e solteiro/a foram assinaladas na variável estado_civil...

c("casado/a","solteiro/a") %in% df$estado_civil

# se quisermos saber se há menores de 18 anos na amostra

df$idade %in% 0:17
```

Mais a frente veremos uma combinação do operador `%in%` com a função `filter()`. 

## Pacote `dplyr`

Esse pacote da família `tidyverse` apresenta um conjunto de funções que permite selecionar variáveis, filtrar observações, selecionar linhas, organizar apresentação de resultados, criar e/ou modificar variáveis, agrupar variáveis, entre outras.
Esses comandos são conhecidos como os **verbos do dplyr**.

```{r echo=FALSE}
tidyverse_table <- data.frame("Funções tidyverse(dplyer)"=c(
                              "select()",
                              "filter()",
                              "slice()",
                              "arrange()",
                              "mutate()",
                              "group_by()"),
                              "O que faz"=c("seleciona colunas do dataframe",
                                            "filtra linhas por categoria de variável",
                                            "filtra linhas inteiras do dataframe",
                                            "reordena as linhas do dataframe",
                                            "cria novas colunas no dataframe",
                                            "realiza os comandos que vierem a seguir pelas variáveis selecionadas"))
library(knitr)

tidyverse_table %>% kable(format = "markdown")
```

Vamos testar uma por uma, com o nosso dataframe df, começando pela função `select()`, que seleciona **colunas** do dataframe.

### select()

```{r}
# SELECT

names(df) # visualisar número das colunas
df %>% names() %>% as.data.frame()

# pegar df e selecionar as colunas 1,2,4,5 e de 9 a 13

## Antes a gente fazia assim...
df[ ,c("id","sexo","escolaridade","estado_civil","v1","v2","v3","v4","v5")]

## Agora usando a função select()

df %>% select(1,2,4,5,9:13) # o comando pipe diz o que é pra fazer com o dataframe 

df %>% select(id, sexo, escolaridade, estado_civil,v1,v2,v3,v4,v5)
### note que o dplyr não requer aspas para o nome das colunas.


# podemos salvar esse novo dataframe com um novo nome. Ao rodar o código abaixo, será criado um objeto df1 no Global Environment

df1 <- df %>% select(1,2,4,5,9:13)

# usar select para deletar uma coluna 

df1 %>% select(-4) # deletar a coluna estado_civil

# usar select para reordenar as colunas

df1 %>% select(5:9,1,3,2,4)  

## OU

df1 %>% select(5:9,everything())

# Outras possibilidades

df %>% select(contains("cola"))

df %>% select(ends_with("dade"))

df %>% select(starts_with("v"))

# vamos aproveitar e deletar as duas últimas colunas do df, colunas 14 e 15

df %>% select(-14,-15)
df %>% select(-c(14,15))
df %>% select(-c(renda_cod,escola_cod))

df <- df %>% select(-c(renda_cod,escola_cod))

# se quiser selecionar um grupo de variáveis que começam com as mesmas letras

df %>% select(starts_with("v"))
df %>% select(starts_with(c("v","sum","mean")))

# ou selecionar variáveis que terminam com as mesmas letras (ou números)

df %>% select(ends_with("dade"))

# seleção de variáveis usando operadores booleanos

df %>% select(!ends_with("dade"))

df %>% select(where(is.factor))

df %>% select(where(is.numeric) & starts_with(c("i")))
df %>% select(where(is.numeric) & starts_with(c("i","v")))

```

### filter()

Se a função `select()` permite a seleção de colunas de um dataframe, a função `filter()` permite a seleção de **linhas**.

```{r}
## se quisermos filtrar somente os participantes do sexo masculino

df %>% filter(sexo == "masculino")

## pode-se acrescentar outras variáveis para filtrar
## por exemplo, filtrar participantes do sexo masculino, com nivel fundamental de escolaridade

df %>% filter(sexo == "masculino",escolaridade == "fundamental")

## ou ainda participantes do sexo masculino, do esnisno fundamental e solteiro/a
df %>% filter(sexo == "masculino",escolaridade == "fundamental",estado_civil == "solteiro/a")

## se quisermos retirar do banco todos os participantes com ensino fundamental.
## observe que o ponto de exclamação no código é uma espécie de "tudo, menos..."
df %>% filter(!escolaridade == "fundamental")
df %>% filter(!escolaridade == "fundamental",renda>=3000)

## ou, se quiser selecionar participantes com renda_total superior ou igual a R$ 2000,00.
df %>% filter(renda_total >= 2000)

## se quisermos selecionar uma subamostra com base em duas ou mais informações DE UMA MESMA VARIÁVEL, podemos usar a função %in%

df %>% filter(escolaridade == "fundamental", escolaridade == "superior") 
# Esse comando acima NÃO FUNCIONA porque estamos tentando selecionar duas condições dentro da mesma variável. Aí, nesse caso precisamos combinar a função filter com o operador %in%

df %>% filter(escolaridade %in% c("fundamental", "médio")) # FUNCIONA


## OBS.: lembrando que se quisermos salvar a filtragem em um novo dataframe...
df_renda_maior2000 <- df %>% filter(renda_total >= 2000)
```

As funções `select()` e `filter()` são muito úteis para limpeza do banco de dados.
Por exemplo, quando baixamos um banco de dados do google formulário, ele vem com as informações de data e hora que o participante respondeu o questionário, com as respoostas ao TCLE, que normalmente não iremos utilizar nas análises.
Então, podemos deletá-las usando a função `select()`.
Outra aplicação muito comum é para criar um *subset* do arquivo base, que contenha somente os itens de um dos instrumentos, para análise de suas propriedades psicométrias.\

De forma semelhante, podemos usar a função `filter()` para eliminar sujeitos que não atendem aos critérios de inclusão da pesquisa.
Ou selecionar um *subset* do banco de dados, que contenha os sujeitos de interesse.

### slice()

Uma opção para selecionar casos com base na linha inteira é a função `slice()`.

```{r}
# selecionar linhas inteiras
df %>% slice(1:3)
df %>% slice(1,4,6)

# selecionar por exclusão
df %>% slice(-1)
df %>% slice(-c(1,6))
df %>% slice(-1,-6)

# sortear uma proporção do banco de dados
df %>% slice_sample(prop = .35)
df %>% slice_sample(n=3)
```

### arrange()

Por sua vez, a função `arrange()`, ordena os dados por um critério.

```{r}
# Ordenar df por idade
df %>% arrange(idade)

# Ordenar df por ordem decrescente de renda_total
df %>% arrange(desc(renda_total))

# É possível inserir mais de uma variável, por exemplo, sexo e renda_total
df %>% arrange(sexo,desc(renda_total))
```

A função `mutate()` permite criar variáveis dentro de um dataframe.
É muito útil para calcular pontuações a partir de itens, por exemplo, ou para fazer transformações de outras variáveis.\

### mutate

```{r}
# calcular as pontuações das pessoas nos itens de v1 a v5.
df %>% mutate(escore = v1+v2+v3+v4+v5)
df %>% mutate(escore = (v1+v2+v3+v4+v5)/5)
# se quisermos salvar a nova variável, então o código seria...
df <- df %>% mutate(escore = v1+v2+v3+v4+v5)

# remover label da variável escore
# escore <- unvr(df$escore)
# df$escore <- escore
# glimpse(df)
```

### group_by

A função `group_by` agrupa os resultados de uma operação e, geralmente, é usada juntamente com alguma outra operação, como por exemplo, a função `summarise()`.

```{r}

# calcular as médias da variável escore, por sexo (grupo_by(sexo))
df %>% group_by(sexo) %>% count(escolaridade)
df %>% group_by(sexo) %>% summarise(mean(escore))
df %>% group_by(sexo,escolaridade) %>% summarise(mean(escore))
```

### rename

Às vezes, é necessário renomear uma ou mais variáveis de um dataframe.
Para isso, podemos usar a função `rename()` do dyplr.

```{r}
df %>% rename(item1 = v1,
              item2 = v2,
              item3 = v3,
              item4 = v4,
              item5 = v5)
```

# Exercícios 4

```{r eval=FALSE, include=FALSE}
imdb <- read_csv("imdb.csv")
saveRDS(imdb,"imdb.rds")

```

Nos próximos exercícios vamos trabalhar com a base de dados imdb, que apresenta uma série de informações sobre filmes disponibilizados pela Amazon.
Baixe o dataframe [aqui](ATUALIZAR) e importe-o para dentro do RStudio e use as funções do tidyverse para resolver os próximos exercícios.

```{r eval=FALSE, include=FALSE}
imdb <- readRDS("imdb.rds")
```

1. Crie uma variável id para todos os sujeitos do dataframe e coloque essa variável na primeira coluna. Não se esqueça de salvar essa transformação no dataframe imdb.

```{r eval=FALSE, include=FALSE}
imdb$id <- paste("s",1:nrow(imdb),sep = "")

imdb <- imdb %>% select(id,everything())
```

2. Selecione as variáveis título, duração, cor e gênero dos 1000 primeiros casos do banco de dados. Não precisa salvar.

```{r eval=FALSE, include=FALSE}
imdb %>% select(titulo,duracao,cor,generos) %>% slice(1:1000)
```

3. Monte um dataframe somente com os filmes do diretor Clint Eastwood. Salve-o como imdb_clint.

```{r eval=FALSE, include=FALSE}
imdb_clint <- imdb %>% filter(diretor == "Clint Eastwood")
```

4. Reorganize o dataframe com filmes do diretor Clint Eastwood por ordem decrescente de receita e visualise os dados para ver se funcionou. Salve o dataframe com o mesmo nome.

```{r eval=FALSE, include=FALSE}
imdb_clint <- imdb_clint %>% arrange(desc(receita))
imdb_clint
```

5. Selecione uma amostra aleatória do dataframe imdb com 45% dos filmes relacionados. Não precisa salvar.

```{r eval=FALSE, include=FALSE}
imdb %>% slice_sample(prop = .45)
```

6. Calcule as médias de orçamento e de receita, por diretor. Salve o resultado num objeto chamado imdb_lucro. Obs.: Nos resultados vão aparecer sinais como NA ou NaN, porque há informações não disponíveis que acabam não permitindo os cálculos desejados.

```{r eval=FALSE, include=FALSE}
view(imdb)

imdb %>% filter(diretor == "James Cameron" | diretor == "Steven Spielberg" | diretor == "Francis Ford Coppola" | diretor == "Tim Burton") %>% group_by(diretor) %>% summarise(imdb = mean(nota_imdb, na.rm = TRUE))
imdb_lucro <- imdb %>% group_by(diretor) %>% summarise(Orçamento_médio = mean(orcamento, na.rm = TRUE), Receita_média = mean(receita, na.rm = TRUE))
```

7. No dataframe anterior, crie a variável lucro, a partir das médias de orçamento e receita. Identifique o diretor mais lucrativo e o que dá mais prejuízo.

```{r eval=FALSE, include=FALSE}
# o mais lucrativo
imdb_lucro %>% mutate(lucro = Receita_média - Orçamento_médio) %>% arrange(desc(lucro))

# o que dá mais prejuízo
imdb_lucro %>% mutate(lucro = Receita_média - Orçamento_médio) %>% arrange(lucro)

# identificação, por curiosidade, do lucro obtido por James Cameron
imdb_lucro %>% mutate(lucro = Receita_média - Orçamento_médio) %>% arrange(lucro) %>% filter(diretor == "James Cameron")

# Para identificar a posição de um diretor em termos de lucratividade
imdb_lucro$posição <- paste(1:nrow(imdb_lucro),sep = "")

imdb_lucro %>% filter(diretor == "Daniel Myrick")
```

8. Voltando ao dataframe completo (imdb). Obtenha um dataframe que contenha somente os diretores que tiverem 3 filmes ou mais no catálogo.

Dica1: A informação de quantos filmes cada diretor tem, não está diretamente disponível no dataframe.
O que a gente tem é uma linha por filme.
Então, o mesmo diretor pode constar em várias linhas, correspondentes aos filmes que ele dirigiu.

Dica2: nesse caso, temos que usar o operador `%in%` ao invés de `==` porque `%in%` permite comparar objetos de tamanhos diferentes, enquanto o `==` só permite comparar objetos de tamanhos iguais, ou uma coluna com UMA informação.
Veja o exemplo com o dataframe big_five

```{r echo=TRUE}
# no dataframe big_five, se quisermos filtrar os participantes estadunidenses, podemos usar o filter. 
big_five %>% filter(país == "US") %>% glimpse()

# porém, se quisermos filtrar os países com mais de 100 participantes, podemos fazer o seguinte:
# pegue o dataframe big_five; ENTÃO, conte a frequência dos países; ENTÃO, filtre os países cujo n for maior que 100. Guarde essa tabela num objeto chamado pais.
pais <- big_five %>% count(país) %>% filter(n>=100)

# guardar somente a coluna com o nome dos países selecionados.
lista_país <- pais$país

# com isso obtemos uma lista dos países (lista_país) que contêm mais de 100 participantes. Agora, queremos selecionar em big_five$país somente aqueles que forem iguais a um dos países constantes na lista_país. Para isso temos que usar o código %in% ao invés de == 

big_five %>% filter(país %in% lista_país) %>% glimpse()

# se rodarmos com == no lugar de %in% vai dar erro porque o comprimento da lista não é igual ao comprimento do dataframe big_five.

#big_five %>% filter(país == lista_país) 

```

```{r eval=FALSE, include=FALSE}
# contar a ocorrência de diretores e filtrar os que aparecem 3x ou mais.
imdb_diretores_3mais <- imdb %>% count(diretor) %>% filter(n>=3) %>% arrange(n)

# retirar somente o vetor "diretores" do objeto imdb_diretores_3mais 
vetor_diretores <- imdb_diretores_3mais$diretor

# filtrar imdb caso o que estiver em diretor seja igual a um dos diretores constantes no vetor_diretores. 
imdb_sub1 <- imdb %>% filter(diretor %in% vetor_diretores)
```

9. Entre os diretores com 3 filmes ou mais, qual tem maior média de nota_imdb?

```{r eval=FALSE, include=FALSE}
imdb_sub1 %>% group_by(diretor) %>% summarise(média_imdb = mean(nota_imdb)) %>% arrange(desc(média_imdb))
```
